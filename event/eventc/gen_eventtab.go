/*
 * This file is part of Golaxy Distributed Service Development Framework.
 *
 * Golaxy Distributed Service Development Framework is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * Golaxy Distributed Service Development Framework is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Golaxy Distributed Service Development Framework. If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright (c) 2024 pangdogs.
 */

package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/spf13/viper"
)

func genEventTab() {
	declFile := viper.GetString("decl_file")
	packageEventAlias := viper.GetString("package_event_alias")
	exportInterface := viper.GetBool("export_interface")
	pkg := viper.GetString("package")
	dir := viper.GetString("dir")
	tabName := viper.GetString("name")

	// 解析事件定义
	eventDeclTab := EventDeclTab{}
	eventDeclTab.Parse()

	code := &bytes.Buffer{}

	// 生成注释
	{
		program := strings.TrimSuffix(filepath.Base(os.Args[0]), filepath.Ext(os.Args[0]))
		args := strings.Join(os.Args[1:], " ")
		copyright := copyrightNotice

		if !viper.GetBool("copyright") {
			copyright = ""
		}

		fmt.Fprintf(code, `%s// Code generated by %s %s; DO NOT EDIT.

package %s
`, copyright, program, args, pkg)
	}

	// 生成import
	{
		importCode := &bytes.Buffer{}

		fmt.Fprintf(importCode, "\nimport (")

		fmt.Fprintf(importCode, `
	%s "%s"`, packageEventAlias, packageEventPath)

		fmt.Fprintf(importCode, "\n)\n")

		fmt.Fprintf(code, importCode.String())
	}

	// event包前缀
	eventPrefix := ""
	if packageEventAlias != "." {
		eventPrefix = packageEventAlias + "."
	}

	// 生成事件表接口
	{
		var eventsCode string

		for _, event := range eventDeclTab.Events {
			eventsCode += fmt.Sprintf("\t%s() %sIEvent\n", event.Name, eventPrefix)
		}

		if exportInterface {
			fmt.Fprintf(code, `
type I%[1]s interface {
%[2]s}
`, strings.Title(tabName), eventsCode)
		} else {
			fmt.Fprintf(code, `
type i%[1]s interface {
%[2]s}
`, strings.Title(tabName), eventsCode)
		}
	}

	// 生成事件表
	{
		// 生成递归设置
		var allEventsSetRecursionCode, caseEventsSetRecursionCode string
		caseEventsRecursion := map[int]string{}
		getEventsSetRecursionCode := map[int]string{}

		for i, event := range eventDeclTab.Events {
			eventRecursion := "recursion"

			// 解析atti
			atti := parseGenAtti(event.Comment, "+event-tab-gen:")

			if atti.Has("recursion") {
				switch atti.Get("recursion") {
				case "allow":
					eventRecursion = eventPrefix + "EventRecursion_Allow"
				case "disallow":
					eventRecursion = eventPrefix + "EventRecursion_Disallow"
				case "discard":
					eventRecursion = eventPrefix + "EventRecursion_Discard"
				case "skip_received":
					eventRecursion = eventPrefix + "EventRecursion_SkipReceived"
				case "receive_once":
					eventRecursion = eventPrefix + "EventRecursion_ReceiveOnce"
				}
				getEventsSetRecursionCode[i] = fmt.Sprintf("\n\t(*eventTab).SetRecursion(%s)", eventRecursion)
				caseEventsRecursion[i] = eventRecursion
			}
			allEventsSetRecursionCode += fmt.Sprintf("\n\t(*eventTab)[%d].SetRecursion(%s)", i, eventRecursion)
		}

		if len(getEventsSetRecursionCode) > 0 {
			caseEventsSetRecursionCode = "\n\tswitch pos {"

			for i := range eventDeclTab.Events {
				eventRecursion, ok := caseEventsRecursion[i]
				if !ok {
					continue
				}
				caseEventsSetRecursionCode += fmt.Sprintf("\n\tcase %[1]d:\n\t\t(*eventTab)[%[1]d].SetRecursion(%s)", i, eventRecursion)
			}

			caseEventsSetRecursionCode += "\n\t}"
		}

		// 生成事件Id
		{
			fmt.Fprintln(code, `
var (`)
			fmt.Fprintf(code, `	_%[1]sId = %[2]sDeclareEventTabIdT[%[1]s]()
`, tabName, eventPrefix)

			for i, event := range eventDeclTab.Events {
				fmt.Fprintf(code, `	%[2]sId = _%[1]sId + %[3]d
`, tabName, event.Name, i)
			}

			fmt.Fprintln(code, ")")
		}

		fmt.Fprintf(code, `
type %[1]s [%[2]d]%[4]sEvent

func (eventTab *%[1]s) SetPanicHandling(autoRecover bool, reportError chan error) {
	for i := range *eventTab {
		(*eventTab)[i].SetPanicHandling(autoRecover, reportError)
	}
}

func (eventTab *%[1]s) SetRecursion(recursion %[4]sEventRecursion) {%[3]s
}

func (eventTab *%[1]s) SetEnable(b bool) {
	for i := range *eventTab {
		(*eventTab)[i].SetEnable(b)
	}
}

func (eventTab *%[1]s) UnbindAll() {
	for i := range *eventTab {
		(*eventTab)[i].UnbindAll()
	}
}

func (eventTab *%[1]s) Ctrl() %[4]sIEventCtrl {
	return eventTab
}

func (eventTab *%[1]s) Event(id uint64) %[4]sIEvent {
	if _%[1]sId != id & 0xFFFFFFFF00000000 {
		return nil
	}
	pos := id & 0xFFFFFFFF
	if pos >= uint64(len(*eventTab)) {
		return nil
	}%[5]s
	return &(*eventTab)[pos]
}
`, tabName, len(eventDeclTab.Events), allEventsSetRecursionCode, eventPrefix, caseEventsSetRecursionCode)

		for i, event := range eventDeclTab.Events {
			fmt.Fprintf(code, `
func (eventTab *%[1]s) %[2]s() %[4]sIEvent {%[5]s
	return &(*eventTab)[%[3]d]
}
`, tabName, event.Name, i, eventPrefix, getEventsSetRecursionCode[i])
		}
	}

	log.Printf("EventTab: %s", tabName)

	// 输出文件
	outFile := filepath.Base(strings.TrimSuffix(declFile, ".go"))
	if !strings.HasSuffix(outFile, "_event") {
		outFile = outFile + "_event"
	}
	outFile = filepath.Join(dir, outFile+"tab.gen.go")

	os.MkdirAll(filepath.Dir(outFile), os.ModePerm)

	if err := ioutil.WriteFile(outFile, code.Bytes(), os.ModePerm); err != nil {
		panic(err)
	}
}
